

计算机系统的输入和输出系统都有哪些呢?我们能举出来的，例如键盘、鼠标、显示器、网卡、硬盘、打印机、CD/DVD等 等，多种多样。
这样，当然方便用户使用了，但是对于操作系统来讲，却是一件复杂的事情，因为这么多设备，形状、用法、 功能都不一样，怎么才能统一管理起来呢?


# 用设备控制器屏蔽设备差异

CPU并不直接和设备打交道，它们中间有一个叫作设备控制器(Device Control Unit)的组件，例如 硬盘有磁盘控制器、USB有USB控制器、显示器有视频控制器等。


输入输出设备我们大致可以分为两类:块设备(Block Device)和字符设备(Character Device)。 块设备将信息存储在固定大小的块中，每个块都有自己的地址。硬盘就是常⻅的块设备。
字符设备发送或接受的是字节流。而不用考虑任何块结构，没有办法寻址。鼠标就是常⻅的字符设备。


CPU如何同控制器的寄存器和数据缓冲区进行通信呢?
每个控制寄存器被分配一个I/O端口，我们可以通过特殊的汇编指令(例如in/out类似的指令)操作这些寄存器。 
数据缓冲区，可内存映射I/O，可以分配一段内存空间给它，就像读写内存一样读写数据缓冲区。如果你去看内存空间的 话，有一个原来我们没有讲过的区域ioremap，就是做这个的。



对于CPU来讲，这些外部设备都有自己的大脑，可以自行处理一些事情，但是有个问题是，当你给设备发了一个指令，让它 读取一些数据，它读完的时候，怎么通知你呢?
控制器的寄存器一般会有状态标志位，可以通过检测状态标志位，来确定输入或者输出操作是否完成。第一种方式就是轮询等 待，就是一直查，一直查，直到完成。
当然这种方式很不好，于是我们有了第二种方式，就是可以通过中断的方式，通知操作 系统输入输出操作已经完成。

还记得32位系统调用是通过INT产生软中断触发的么?这就 统一起来了，中断有两种，一种软中断，例如代码调用INT指令触发，一种是硬件中断，就是硬件通过中断控制器触发的。

有的设备需要读取或者写入大量数据。如果所有过程都让CPU协调的话，就需要占用CPU大量的时间，比方说，磁盘就是这 样的。
这种类型的设备需要支持DMA功能，也就是说，允许设备在CPU不参与的情况下，能够自行完成对内存的读写。实现 DMA机制需要有个DMA控制器帮你的CPU来做协调，就像下面这个图中显示的一样。




# 用驱动程序屏蔽设备控制器差异

设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。操作系统的内核代码可 以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制 器。

对于块设备来讲，在驱动程序之上，文件系统之下，还需要一层通用设备层。比如咱们上一章讲的文件系统，里面的逻 辑和磁盘设备没有什么关系，可以说是通用的逻辑。
在写文件的最底层，我们看到了BIO字眼的函数，但是好像和设备驱动也 没有什么关系。是的，因为块设备类型非常多，而Linux操作系统里面一切是文件。
我们也不想文件系统以下，就直接对接各 种各样的块设备驱动程序，这样会使得文件系统的复杂度非常高。
所以，我们在中间加了一层通用块层，将与块设备相关的通 用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序。



#  用文件系统接口屏蔽驱动程序的差异

















































