# 讲文件缓存:常用文档应该放在触手可得的地方

通过打开文件的过程，构建了一个文件管理的整套数据结构体系


# 系统调用层和虚拟文件系统层

文件系统的读写，其实就是调用系统函数read和write


# ext4文件系统层

缓存其实就是内存中的一块空间。因为内存比硬盘快的多，Linux为了改进性能，有时候会选择不直接操作硬盘，而是将读写
都在内存中，然后批量读取或者写入硬盘。一旦能够命中内存，读写效率就会大幅度提高。

根据是否使用内存做缓存，我们可以把文件的I/O操作分为两种类型。


第一种类型是缓存I/O。大多数文件系统的默认I/O操作都是缓存I/O。
至于什么时候再写 到磁盘中由操作系统决定，除非显式地调用了sync同步命令。

第二种类型是直接IO，就是应用程序直接访问磁盘数据，而不经过内核缓冲区，从而减少了在内核缓存和用户程序之间数据复制。


# 带缓存的写入操作

这个函数里，是一个while循环。我们需要找出这次写入影响的所有的⻚，然后依次写入。对于每一个循环，主要做四件事 情:
对于每一⻚，先调用address_space的write_begin做一些准备; 调用iov_iter_copy_from_user_atomic，
将写入的内容从用户态拷⻉到内核态的⻚中; 
调用address_space的write_end完成写操作; 
调用balance_dirty_pages_ratelimited，看脏⻚是否太多，需要写回硬盘。所谓脏⻚，就是写入到缓存，但是还没有写入到 硬盘的⻚面。


第一步，对于ext4来讲，调用的是ext4_write_begin。

ext4是一种日志文件系统，是为了防止突然断电的时候的数据丢失，引入了日志**(Journal)**模式。

另一种模式是order模式。这个模式不记录数据的日志，只记录元数据的日志，但是在写元数据的日志前，必须先确保数据已 经落盘。这个折中，是默认模式。

还有一种模式是writeback，不记录数据的日志，仅记录元数据的日志，并且不保证数据比元数据先落盘。这个性能最好，但 是最不安全。


在内核中，缓存以⻚为单位放在内存里面，那我们如何知道，一个文件的哪些数据已经被放到缓存中了呢?每一个打开的文件 
都有一个struct file结构，每个struct file结构都有一个struct address_space用于关联文件和内存，就是在这个结构里面，有一 棵树，用于保存所有与这个文件相关的的缓存⻚。




第二步，调用iov_iter_copy_from_user_atomic。先将分配好的⻚面调用kmap_atomic映射到内核里面的一个虚拟地址，
然后 将用户态的数据拷⻉到内核态的⻚面的虚拟地址中，调用kunmap_atomic把内核里面的映射删除。



第三步，调用ext4_write_end完成写入。这里面会调用ext4_journal_stop完成日志的写入，会调用block_write_end- >__block_commit_write->mark_buffer_dirty，
将修改过的缓存标记为脏⻚。可以看出，其实所谓的完成写入，并没有真正写 入硬盘，仅仅是写入缓存后，标记为脏⻚。
但是这里有一个问题，数据很危险，一旦宕机就没有了，所以需要一种机制，将写入的⻚面真正写到硬盘中，我们称为回写 (Write Back)。


第四步，调用 balance_dirty_pages_ratelimited，是回写脏⻚的一个很好的时机。


# 带缓存的读操作



























