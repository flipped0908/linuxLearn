
硬盘

每一层里分多个磁道，每 个磁道分多个扇区，每个扇区是512个字节。


# inode与块的存储  

硬盘分成相同大小的单元，我们称为块(Block)。

一块的大 小是扇区大小的整数倍，默认是4K

用来维护“某个文件分成几块、每一块在哪里“等等这些基本信息?

文件还有元数据部分，例如名字、权限等，这就需要一个结构inode来存放。

inode的“i”是index的意思，其实就是“索引”，

我们每个文件都会对应一个
inode;一个文件夹就是一个文件，也对应一个inode。


inode里面有文件的读写权限i_mode，属于哪个用户i_uid，哪个组i_gid，大小是多少 i_size_io，占用多少个块i_blocks_io。

i_atime是access time，是最近一次访问文件的时间;i_ctime是change time，是 最近一次更改inode的时间;i_mtime是modify time，是最近一次更改文件的时间。



在ext2和ext3中，其中前12项直接保存了块的位置，也就是说，我们可以通过i_block[0-11]，直接得到保存文件内容的块。

如果一个文件比较大，12块放不下。当我们用到i_block[12]的时候，就不能直接放数据块的位置了，要不然i_block很快 就会用完了。这该怎么办呢?我们需要想个办法。
我们可以让i_block[12]指向一个块，这个块里面不放数据块，而是放数据块 的位置，这个块我们称为间接块。

i_block[13]会指向一个块，我们可以用二次间接块。二次间接块里面存放了间接块的位置，间接块里面存 放了数据块的位置，
数据块里面存放的是真正的数据。如果文件再大一些，i_block[14]会指向三次间接块
原理和上面都是一 样的，就像一层套一层的俄罗斯套娃，一层一层打开，才能拿到最中心的数据块。


如果你稍微有点经验，现在你应该能够意识到，这里面有一个非常显著的问题，对于大文件来讲，我们要多次读取硬盘才能找 到相应的块，这样访问速度就会比较慢。
为了解决这个问题，ext4做了一定的改变。它引入了一个新的概念，叫作Extents。


我们来解释一下Extents。比方说，一个文件大小为128M，如果使用4k大小的块进行存储，需要32k个块。
如果按照ext2或者 ext3那样散着放，数量太大了。但是Extents可以用于存放连续的块，也就是说，我们可以把128M放在一个Extents里面。这样 的话，对大文件的读写性能提高了，文件碎片也减少了。



Exents如何来存储呢?它其实会保存成一棵树。

树有一个个的节点，有叶子节点，也有分支节点。每个节点都有一个头，ext4_extent_header可以用来描述某个节点。

我们仔细来看里面的内容。eh_entries表示这个节点里面有多少项。这里的项分两种，如果是叶子节点，这一项会直接指向硬 盘上的连续块的地址，
我们称为数据节点ext4_extent;如果是分支节点，这一项会指向下一层的分支节点或者叶子节点，我 们称为索引节点ext4_extent_idx。这两种类型的项的大小都是12个byte。


除了根节点，其他的节点都保存在一个块4k里面，4k扣除ext4_extent_header的12个byte，剩下的能够放340项，每个extent 最大能表示128MB的数据，340个extent会使你的表示的文件达到42.5GB。这已经非常大了，如果再大，我们可以增加树的深 度。



# inode位图和块位图


硬盘上肯定有一系列的inode和一系列的块排列起来。

所以在文件系统里面，我们专⻔弄了一个块来保存inode的位图。
在这4k里面，每一位对应一个 inode。如果是1，表示这个inode已经被用了;如果是0，则表示没被用。
同样，我们也弄了一个块保存block的位图。


open是一个系统调用，在内核里面会调用 sys_open，定义如下:
```  
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) {
if (force_o_largefile()) flags |= O_LARGEFILE;
return do_sys_open(AT_FDCWD, filename, flags, mode); }
```

do_sys_open-> do_filp_open->path_openat->do_last->lookup_open。
这个调用链的逻辑是，要 打开一个文件，先要根据路径找到文件夹。如果发现文件夹下面没有这个文件，
同时又设置了O_CREAT，就说明我们要在这 个文件夹下面创建一个文件，那我们就需要一个新的inode。


想要创建新的inode，我们就要调用dir_inode，也就是文件夹的inode的create函数。它的具体定义是这样的:


接下来的调用链是这样的:ext4_create->ext4_new_inode_start_handle->__ext4_new_inode。在__ext4_new_inode函数 中，我们会创建新的inode。




# 文件系统的格式


这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称 为块组描述符表。



对于超级块来讲，由于超级块不是很大，所以就算我们备份多了也没有太多问题。但是，对于块组描述符表来讲，如果每个块 组里面都保存一份完整的块组描述符表，一方面很浪费空间;
另一个方面，由于一个块组最大128M，而块组描述符表里面有 多少项，这就限制了有多少个块组，128M * 块组的总数目是整个文件系统的大小，就被限制住了。
我们的改进的思路就是引入Meta Block Groups特性。


这样化整为零，我们就可以发挥出ext4的48位块寻址的优势了，
在超级块ext4_super_block的定义中，我们可以看到块寻址的 分为高位和地位，均为32位，其中有用的是48位，2^48个块是1EB，足够用了。



# 目录的存储格式

其实目录本身也是个文件，也有inode。inode里面也是指向一些块。和普通文件不同的是，普通文件的块里面保存的是文件数 据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为ext4_dir_entry。




#  软链接和硬链接的存储格式


在讲操作文件的命令的时候，我们讲过软链接 的概念。所谓的链接(Link)，我们可以认为是文件的别名，而链接又可分为两种，硬链接与软链接。通过下面的命令可以创 建。


ln -s创建的是软链接，不带-s创建的是硬链接。它们有什么区别呢?在文件系统里面是怎么保存的呢?


如图所示，硬链接与原始文件共用一个inode的，但是inode是不跨文件系统的，每个文件系统都有自己的inode列表，因而硬 链接是没有办法跨文件系统的。

而软链接不同，软链接相当于重新创建了一个文件。这个文件也有独立的inode，只不过打开这个文件看里面内容的时候，内 容指向另外的一个文件。这就很灵活了。我们可以跨文件系统，甚至目标文件被删除了，链接文件还是在的，只不过指向的文 件找不到了而已。



# 总结时刻
这一节，我们描述了复杂的硬盘上的文件系统，但是对于咱们平时的应用来讲，用的最多的是两个概念，一个是inode，一个 是数据块。


为了表示图中上半部分的那个简单的树形结构，在文件系统上的布局就像图的下半部分一样。

无论是文件夹还是文件，都有一 个inode。inode里面会指向数据块，对于文件夹的数据块，里面是一个表，是下一层的文件名和inode的对应关系，文件的数 据块里面存放的才是真正的数据。





































