

虚拟内存空间如何组织的，也看了物理⻚面如何管理的。现在我们需要一些数据结构，将二者关联起 来。 

# mmap的原理
在虚拟地址空间那一节，我们知道，每一个进程都有一个列表vm_area_struct，指向虚拟地址空间的不同的内存块，这个变量 的名字叫mmap。

其实内存映射不仅仅是物理内存和虚拟内存之间的映射，还包括将文件中的内容映射到虚拟内存空间。
这个时候，访问内存空 间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。


如果我们要申请小块内存，就用brk


如果一个进程想映射一个文件到自己的虚拟内存空间，也要通过mmap系统调用。这个时候mmap是映射内存空间到物 理内存再到文件。
可⻅mmap这个系统调用是核心，我们现在来看mmap这个系统调用。


果要映射到文件，fd会传进来一个文件描述符，并且mmap_pgoff里面通过fget函数，根据文件描述符获得struct file。struct file表示打开的一个文件。


接下来的调用链是vm_mmap_pgoff->do_mmap_pgoff->do_mmap。  
这里面主要干了两件事情:   
调用get_unmapped_area找到一个没有映射的区域;  
调用mmap_region映射这个区域。


这里面如果是匿名映射，则调用mm_struct里面的get_unmapped_area函数。这个函数其实是arch_get_unmapped_area。它 会调用find_vma_prev，
在表示虚拟内存区域的vm_area_struct红黑树上找到相应的位置。之所以叫prev，是说这个时候虚拟 内存区域还没有建立，找到前一个vm_area_struct。


如果不是匿名映射，而是映射到一个文件，这样在Linux里面，每个打开的文件都有一个struct file结构，里面有一个 file_operations，
用来表示和这个文件相关的操作。如果是我们熟知的ext4文件系统，调用的是thp_get_unmapped_area。如 果我们仔细看这个函数，
最终还是调用mm_struct里面的get_unmapped_area函数。殊途同归。


我们再来看mmap_region，看它如何映射这个虚拟内存区域。

还记得咱们刚找到了虚拟内存区域的前一个vm_area_struct，我们首先要看，是否能够基于它进行扩展，也即调用 vma_merge，和前一个vm_area_struct合并到一起。

从这个函数的参数可以看出，这一刻文件和内存开始发生关系了。这里我们将 vm_area_struct的内存操作设置为文件系统操作，也就是说，读写内存其实就是读写文件系统。


我们再回到mmap_region函数。最终，vma_link函数将新创建的vm_area_struct挂在了mm_struct里面的红黑树上。  


你可能会困惑，好像还没和物理内存发生任何关系，还是在虚拟内存里面折腾呀?
对的，因为到目前为止，我们还没有开始真正访问内存呀!这个时候，内存管理并不直接分配物理内存，因为物理内存相对于 虚拟地址空间太宝贵了，只有等你真正用的那一刻才会开始分配。


# 用户态缺⻚异常  

一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理⻚，那就触发缺⻚中断，调用do_page_fault。 

接下来在用户空间里面，找到你访问的那个地址所在的区域vm_area_struct，然后调用handle_mm_fault来映射这个区域。 

到这里，终于看到了我们熟悉的PGD、P4G、PUD、PMD、PTE，这就是前面讲⻚表的时候，讲述的四级⻚表的概念

在一个进程新创建的时候，会调用fork，对于内存的部分会调用copy_mm，里面调用dup_mm。 

pgd_alloc里面除了分配PDG之外，还做了很重要的一个事情，就是调用pgd_ctor。

pgd_ctor干了什么事情呢?我们注意看里面的注释，它拷⻉了对于swapper_pg_dir的引用。swapper_pg_dir是内核⻚表的最 顶级的全局⻚目录。 

，一个进程fork完毕之后，有了内核⻚表，有了自己顶级的pgd，但是对于用户地址空间来讲，还完全没有映射过。这需 要等到这个进程在某个CPU上运行，并且对内存访问的那一刻了。

绕了一大圈，终于将⻚表整个机制的各个部分串了起来。但是咱们的故事还没讲完，物理的内存还没找到。我们还得接着分析 handle_pte_fault的实现。


这里面总的来说分了三种情况。  
如果PTE，也就是⻚表项，从来没有出现过，那就是新映射的⻚。  
如果是匿名⻚，就是第一种 情况，应该映射到一个物理内存⻚，在这里调用的是do_anonymous_page。如果是映射到文件，调用的就是do_fault，这是 第二种情况。  
如果PTE原来出现过，说明原来⻚面在物理内存中，后来换出到硬盘了，现在应该换回来，调用的是 do_swap_page。


为了提高映射速度，我们引入了TLB(Translation Lookaside Buffer)，我们经常称为快表，专⻔用来做地址映射的硬件设 备。
它不在内存中，可存储的数据比较少，但是比内存要快。所以，我们可以想象，TLB就是⻚表的Cache，其中存储了当前 最可能被访问到的⻚表项，其内容是部分⻚表项的一个副本。
有了TLB之后，地址映射的过程就像图中画的。我们先查块表，块表中有映射关系，然后直接转换为物理地址。如果在TLB查 不到映射关系时，才会到内存中查询⻚表。



### 总结时刻
用户态的内存映射机制，我们解析的差不多了，我们来总结一下，用户态的内存映射机制包含以下几个部分。 

用户态内存映射函数mmap，包括用它来做匿名映射和文件映射。 用户态的⻚表结构，存储位置在mm_struct中。
   
在用户态访问没有映射的内存会引发缺⻚异常，分配物理⻚表、补⻬⻚表。如果是匿名映射则分配物理内存;如果是 swap，则将swap文件读入;如果是文件映射，则将文件读入。


#####  课堂练习
你可以试着用mmap系统调用，写一个程序来映射一个文件，并读取文件的内容。